import * as THREE from 'three';
import { TGALoader } from 'three/addons/loaders/TGALoader.js';
import { EXRLoader } from 'three/addons/loaders/EXRLoader.js';

const debugTextures = false;
const debugMaterials = false;
const debugMeshes = false;
const debugPrims = false;
const disableTextures = false;
const disableMaterials = false;

class TextureRegistry {
  constructor(basename, allPaths) {
    this.basename = basename;
    this.allPaths = allPaths;
    this.textures = [];
    this.loader = new THREE.TextureLoader();
    this.tgaLoader = new TGALoader();
    this.exrLoader = new EXRLoader();

    // HACK get URL ?file parameter again
    let urlParams = new URLSearchParams(window.location.search);
    let fileParam = urlParams.get('file');
    if (fileParam) {
      let lastSlash = fileParam.lastIndexOf('/');
      if (lastSlash >= 0)
        fileParam = fileParam.substring(0, lastSlash);
      this.baseUrl = fileParam;
    }
  }

  getTexture(resourcePath) {
    if (debugTextures) console.log("get texture", resourcePath);
    if (this.textures[resourcePath]) {
      return this.textures[resourcePath];
    }

    let textureResolve, textureReject;
    this.textures[resourcePath] = new Promise((resolve, reject) => {
      textureResolve = resolve;
      textureReject = reject;
    });

    if (!resourcePath) {
      return Promise.reject(new Error('Empty resource path for file: ' + resourcePath + ' at ' + this.basename));
    }

    let filetype = undefined;
    let lowercaseFilename = resourcePath.toLowerCase();
    if (lowercaseFilename.indexOf('.png') >= lowercaseFilename.length - 5) {
      filetype = 'image/png';
    } else if (lowercaseFilename.indexOf('.jpg') >= lowercaseFilename.length - 5) {
      filetype = 'image/jpeg';
    } else if (lowercaseFilename.indexOf('.jpeg') >= lowercaseFilename.length - 5) {
      filetype = 'image/jpeg';
    } else if (lowercaseFilename.indexOf('.exr') >= lowercaseFilename.length - 4) {
      console.warn("EXR textures are not fully supported yet", filename);
      // using EXRLoader explicitly
      filetype = 'image/x-exr';
    } else if (lowercaseFilename.indexOf('.tga') >= lowercaseFilename.length - 4) {
      console.warn("TGA textures are not fully supported yet", resourcePath);
      // using TGALoader explicitly
      filetype = 'image/tga';
    } else {
      console.error("Error when loading texture: unknown filetype", resourcePath);
      // throw new Error('Unknown filetype');
    }

    window.driver.getFile(resourcePath, async (loadedFile) => {
      let loader = this.loader;
      if (filetype === 'image/tga')
        loader = this.tgaLoader;
      else if (filetype === 'image/x-exr')
        loader = this.exrLoader;
      
      const baseUrl = this.baseUrl;
      function loadFromFile(_loadedFile) {
        let url = undefined;
        if (debugTextures) console.log("window.driver.getFile",resourcePath, " => ", _loadedFile);
        if (_loadedFile) {
          let blob = new Blob([_loadedFile.slice(0)], {type: filetype});
          url = URL.createObjectURL(blob);
        } else {
          if (baseUrl)
            url = baseUrl + '/' + resourcePath;
          else
            url = resourcePath;
        }
        if (debugTextures) console.log("Loading texture from", url, "with loader", loader, "_loadedFile", _loadedFile, "baseUrl", baseUrl, "resourcePath", resourcePath);
        // Load the texture
        loader.load(
          // resource URL
          url,
  
          // onLoad callback
          (texture) => {
            texture.name = resourcePath;
            textureResolve(texture);
          },
  
          // onProgress callback currently not used
          undefined,
  
          // onError callback
          (err) => {
            textureReject(err);
          }
        );
      }
      
      if (!loadedFile) {
        // if the file is not part of the filesystem, we can still try to fetch it from the network
        if (baseUrl) {
          console.log("File not found in filesystem, trying to fetch", resourcePath);
        }
        else {
          textureReject(new Error('Unknown file: ' + resourcePath));
          return;
        }
      }

      loadFromFile(loadedFile);
    });

    return this.textures[resourcePath];
  }
}

class HydraMesh {
  constructor(id, hydraInterface, isSkinned = false) {
    this._geometry = new THREE.BufferGeometry();
    this._id = id;
    this._interface = hydraInterface;
    this._points = undefined;
    this._normals = undefined;
    this._colors = undefined;
    this._uvs = undefined;
    this._indices = undefined; 
    this._materials = [];
    this._isSkinned = isSkinned;

    let material = new THREE.MeshPhysicalMaterial( {
      side: THREE.DoubleSide,
      color: new THREE.Color(0xB4B4B4),
      envMap: window.envMap,
    } );
    this._materials.push(material);

    if (isSkinned){
      console.log("hi")
      let skinIndices = new THREE.Uint16BufferAttribute([0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0], 4);
      let skinWeights = new THREE.Float32BufferAttribute([1.000000, 0.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 0.7386018, 0.2613982, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 0.7386018, 0.2613982, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 0.7386018, 0.2613982, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 0.7386018, 0.2613982, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 0.7386019, 0.2613981, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 0.7386019, 0.2613981, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 0.7386018, 0.2613982, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 0.7386018, 0.2613982, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 0.7386018, 0.2613982, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 0.7386018, 0.2613982, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 0.7386019, 0.2613981, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 0.7386018, 0.2613982, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 0.7386018, 0.2613982, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 0.7386018, 0.2613982, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 0.7386018, 0.2613982, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 0.7386018, 0.2613982, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 0.7386018, 0.2613982, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 0.7386018, 0.2613982, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 0.7386018, 0.2613982, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 0.7386018, 0.2613982, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 0.7386018, 0.2613982, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 0.7386019, 0.2613981, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 0.7386018, 0.2613982, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 0.7386018, 0.2613982, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 0.7386018, 0.2613982, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 0.7386018, 0.2613982, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 0.7386018, 0.2613982, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 0.7386019, 0.2613981, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 0.7386018, 0.2613982, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 0.7386018, 0.2613982, 0.000000, 0.000000, 0.7386019, 0.2613981, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 0.7386019, 0.2613981, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000], 4);
      this._points = new THREE.Float32BufferAttribute([0.000000, -0.9999996, -4.575077, 0.1950903, -0.9807848, -4.575077, 0.09547430, -0.4799818, 0.000000, 0.3826835, -0.9238791, -4.575077, 0.1872796, -0.4521329, 0.000000, 0.5555703, -0.8314692, -4.575077, 0.2718878, -0.4069089, 0.000000, 0.7071068, -0.7071064, -4.575077, 0.3460475, -0.3460476, 0.000000, 0.8314697, -0.5555698, -4.575077, 0.4069089, -0.2718879, 0.000000, 0.9238795, -0.3826830, -4.575077, 0.4521329, -0.1872797, 0.000000, 0.9807853, -0.1950899, -4.575077, 0.4799817, -0.09547442, 0.000000, 1.000000, 3.244680e-7, -4.575077, 0.4893851, -1.824650e-7, 0.000000, 0.9807853, 0.1950906, -4.575077, 0.4799817, 0.09547406, 0.000000, 0.9238796, 0.3826836, -4.575077, 0.4521329, 0.1872793, 0.000000, 0.8314697, 0.5555706, -4.575077, 0.4069089, 0.2718876, 0.000000, 0.7071068, 0.7071072, -4.575077, 0.3460475, 0.3460473, 0.000000, 0.5555702, 0.8314701, -4.575077, 0.2718878, 0.4069086, 0.000000, 0.3826833, 0.9238801, -4.575077, 0.1872795, 0.4521327, 0.000000, 0.1950901, 0.9807857, -4.575077, 0.09547418, 0.4799815, 0.000000, -3.258410e-7, 1.000000, -4.575077, 0.000000, 0.4893849, 0.000000, -0.1950907, 0.9807856, -4.575077, -0.09547442, 0.4799815, 0.000000, -0.3826839, 0.9238798, -4.575077, -0.1872797, 0.4521325, 0.000000, -0.5555707, 0.8314697, -4.575077, -0.2718879, 0.4069085, 0.000000, -0.7071073, 0.7071068, -4.575077, -0.3460476, 0.3460471, 0.000000, -0.8314700, 0.5555701, -4.575077, -0.4069089, 0.2718873, 0.000000, -0.9238799, 0.3826830, -4.575077, -0.4521329, 0.1872790, 0.000000, -0.9807854, 0.1950898, -4.575077, -0.4799817, 0.09547370, 0.000000, -1.000000, -5.656330e-7, -4.575077, -0.4893850, -6.180670e-7, 0.000000, -0.9807851, -0.1950909, -4.575077, -0.4799815, -0.09547489, 0.000000, -0.9238791, -0.3826841, -4.575077, -0.4521325, -0.1872802, 0.000000, -0.8314689, -0.5555709, -4.575077, -0.7071059, -0.7071073, -4.575077, -0.3460470, -0.3460481, 0.000000, -0.5555691, -0.8314700, -4.575077, -0.2718871, -0.4069093, 0.000000, -0.3826821, -0.9238797, -4.575077, -0.1872788, -0.4521332, 0.000000, -0.3826839, 0.9238798, -4.575077, 0.9238796, 0.3826836, -4.575077, -0.9238791, -0.3826841, -4.575077, -0.1950888, -0.9807851, -4.575077, 0.000000, -0.4893852, 0.000000, -0.09547346, -0.4799820, 0.000000, 0.08780604, 0.4414305, 4.575077, -0.4414310, 0.08780515, 4.575077, 0.4414311, -0.08780664, 4.575077, -0.08780533, -0.4414317, 4.575077, 0.000000, -0.4500797, 4.575077, -0.1722372, -0.4158197, 4.575077, -0.2500500, -0.3742281, 4.575077, -0.4069084, -0.2718884, 0.000000, -0.3182535, -0.3182550, 4.575077, -0.3742268, -0.2500516, 4.575077, -0.4158186, -0.1722388, 4.575077, -0.4414309, -0.08780711, 4.575077, -0.4500791, -9.912810e-7, 4.575077, -0.4414310, 0.08780515, 4.575077, -0.4158191, 0.1722369, 4.575077, -0.3742272, 0.2500498, 4.575077, -0.3182542, 0.3182533, 4.575077, -0.2500507, 0.3742265, 4.575077, -0.1722379, 0.4158183, 4.575077, -0.08780616, 0.4414305, 4.575077, 0.000000, 0.4500786, 4.575077, 0.08780604, 0.4414305, 4.575077, 0.1722378, 0.4158184, 4.575077, 0.2500506, 0.3742266, 4.575077, 0.3182541, 0.3182535, 4.575077, 0.3742272, 0.2500500, 4.575077, 0.4158190, 0.1722372, 4.575077, 0.4414311, 0.08780544, 4.575077, 0.4500792, -5.906650e-7, 4.575077, 0.4414311, -0.08780664, 4.575077, 0.4158190, -0.1722384, 4.575077, 0.3742272, -0.2500511, 4.575077, 0.3182541, -0.3182546, 4.575077, 0.2500507, -0.3742277, 4.575077, 0.1722379, -0.4158194, 4.575077, 0.08780616, -0.4414315, 4.575077, 0.3826835, -0.9238791, -4.575077, 0.1950903, -0.9807848, -4.575077, 0.000000, -0.9999996, -4.575077, -0.1950888, -0.9807851, -4.575077, -0.3826821, -0.9238797, -4.575077, -0.5555691, -0.8314700, -4.575077, -0.7071059, -0.7071073, -4.575077, -0.8314689, -0.5555709, -4.575077, -0.9807851, -0.1950909, -4.575077, -1.000000, -5.656330e-7, -4.575077, -0.9807854, 0.1950898, -4.575077, -0.9238799, 0.3826830, -4.575077, -0.8314700, 0.5555701, -4.575077, -0.7071073, 0.7071068, -4.575077, -0.5555707, 0.8314697, -4.575077, -0.1950907, 0.9807856, -4.575077, -3.258410e-7, 1.000000, -4.575077, 0.1950901, 0.9807857, -4.575077, 0.3826833, 0.9238801, -4.575077, 0.5555702, 0.8314701, -4.575077, 0.7071068, 0.7071072, -4.575077, 0.8314697, 0.5555706, -4.575077, 0.9807853, 0.1950906, -4.575077, 1.000000, 3.244680e-7, -4.575077, 0.9807853, -0.1950899, -4.575077, 0.9238795, -0.3826830, -4.575077, 0.8314697, -0.5555698, -4.575077, 0.7071068, -0.7071064, -4.575077, 0.5555703, -0.8314692, -4.575077, -0.08780533, -0.4414317, 4.575077, 0.000000, -0.4500797, 4.575077, 0.08780616, -0.4414315, 4.575077, 0.1722379, -0.4158194, 4.575077, 0.2500507, -0.3742277, 4.575077, 0.3182541, -0.3182546, 4.575077, 0.3742272, -0.2500511, 4.575077, 0.4158190, -0.1722384, 4.575077, 0.4500792, -5.906650e-7, 4.575077, 0.4414311, 0.08780544, 4.575077, 0.4158190, 0.1722372, 4.575077, 0.3742272, 0.2500500, 4.575077, 0.3182541, 0.3182535, 4.575077, 0.2500506, 0.3742266, 4.575077, 0.1722378, 0.4158184, 4.575077, 0.000000, 0.4500786, 4.575077, -0.2500507, 0.3742265, 4.575077, -0.08780616, 0.4414305, 4.575077, -0.1722379, 0.4158183, 4.575077, -0.3182542, 0.3182533, 4.575077, -0.3742272, 0.2500498, 4.575077, -0.4158191, 0.1722369, 4.575077, -0.4500791, -9.912810e-7, 4.575077, -0.4414309, -0.08780711, 4.575077, -0.4158186, -0.1722388, 4.575077, -0.3742268, -0.2500516, 4.575077, -0.3182535, -0.3182550, 4.575077, -0.2500500, -0.3742281, 4.575077, -0.1722372, -0.4158197, 4.575077], 3);
      this._normals = new THREE.Float32BufferAttribute([5.039020e-7, -0.9938294, 0.1109191, 0.1938866, -0.9747333, 0.1109191, 0.1947389, -0.9790167, 0.06002557, 0.3803219, -0.9181787, 0.1109191, 0.3819937, -0.9222136, 0.06002557, 0.5521420, -0.8263391, 0.1109191, 0.5545684, -0.8299704, 0.06002557, 0.7027436, -0.7027435, 0.1109192, 0.7058315, -0.7058320, 0.06002563, 0.8263392, -0.5521417, 0.1109192, 0.8299701, -0.5545689, 0.06002563, 0.9181789, -0.3803218, 0.1109192, 0.9222137, -0.3819932, 0.06002563, 0.9747333, -0.1938864, 0.1109192, 0.9790168, -0.1947386, 0.06002563, 0.9938294, -1.583690e-7, 0.1109192, 0.9981969, 0.000000, 0.06002569, 0.9747334, 0.1938861, 0.1109192, 0.9790168, 0.1947387, 0.06002569, 0.9181789, 0.3803218, 0.1109192, 0.9222138, 0.3819931, 0.06002575, 0.8263391, 0.5521419, 0.1109193, 0.8299704, 0.5545686, 0.06002575, 0.7027436, 0.7027434, 0.1109194, 0.7058315, 0.7058320, 0.06002575, 0.5521422, 0.8263389, 0.1109194, 0.5545687, 0.8299701, 0.06002575, 0.3803217, 0.9181789, 0.1109194, 0.3819934, 0.9222136, 0.06002575, 0.1938850, 0.9747336, 0.1109194, 0.1947384, 0.9790168, 0.06002581, -2.927430e-7, 0.9938295, 0.1109193, 2.521250e-7, 0.9981968, 0.06002575, -0.1938858, 0.9747335, 0.1109194, -0.1947395, 0.9790167, 0.06002575, -0.3803224, 0.9181786, 0.1109194, -0.3819943, 0.9222133, 0.06002575, -0.5521423, 0.8263389, 0.1109194, -0.5545687, 0.8299702, 0.06002575, -0.7027437, 0.7027433, 0.1109193, -0.7058324, 0.7058311, 0.06002581, -0.8263394, 0.5521415, 0.1109193, -0.8299710, 0.5545675, 0.06002575, -0.9181791, 0.3803210, 0.1109193, -0.9222137, 0.3819931, 0.06002575, -0.9747336, 0.1938852, 0.1109192, -0.9790169, 0.1947383, 0.06002569, -0.9938294, -0.000001055800, 0.1109192, -0.9981969, -8.515170e-7, 0.06002569, -0.9747331, -0.1938876, 0.1109192, -0.9790167, -0.1947395, 0.06002563, -0.9181783, -0.3803234, 0.1109192, -0.9222134, -0.3819942, 0.06002563, -0.8263384, -0.5521429, 0.1109192, -0.7027428, -0.7027444, 0.1109192, -0.7058306, -0.7058328, 0.06002557, -0.5521408, -0.8263399, 0.1109192, -0.5545669, -0.8299714, 0.06002563, -0.3803205, -0.9181793, 0.1109191, -0.3819924, -0.9222141, 0.06002557, 0.000000, 0.000000, -1.000000, 5.199060e-7, 0.000000, -1.000000, -2.256790e-7, 0.000000, -1.000000, -0.1938853, -0.9747336, 0.1109191, 5.779850e-7, -0.9981968, 0.06002557, -0.1947377, -0.9790170, 0.06002557, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 1.000000, 0.000001636460, 0.000000, 1.000000, -0.1950820, -0.9807493, 0.008590877, 6.907190e-7, -0.9999632, 0.008590877, -0.3826677, -0.9238463, 0.008590877, -0.5555484, -0.8314399, 0.008590877, -0.8299701, -0.5545690, 0.06002557, -0.7070795, -0.7070819, 0.008590877, -0.8314383, -0.5555508, 0.008590936, -0.9238448, -0.3826708, 0.008590936, -0.9807488, -0.1950847, 0.008590936, -0.9999632, 0.000000, 0.008590995, -0.9807494, 0.1950817, 0.008590995, -0.9238458, 0.3826684, 0.008590995, -0.8314393, 0.5555494, 0.008590995, -0.7070813, 0.7070801, 0.008590995, -0.5555496, 0.8314391, 0.008591055, -0.3826699, 0.9238452, 0.008591055, -0.1950834, 0.9807491, 0.008591055, 0.000000, 0.9999632, 0.008591055, 0.1950830, 0.9807492, 0.008591055, 0.3826691, 0.9238455, 0.008591055, 0.5555490, 0.8314396, 0.008590995, 0.7070804, 0.7070810, 0.008590995, 0.8314391, 0.5555496, 0.008590995, 0.9238455, 0.3826695, 0.008590995, 0.9807491, 0.1950834, 0.008590995, 0.9999632, 5.906840e-7, 0.008590936, 0.9807492, -0.1950829, 0.008590936, 0.9238454, -0.3826697, 0.008590936, 0.8314392, -0.5555496, 0.008590877, 0.7070811, -0.7070803, 0.008590877, 0.5555495, -0.8314391, 0.008590877, 0.3826688, -0.9238457, 0.008590877, 0.1950835, -0.9807491, 0.008590877, 4.232080e-7, 0.000000, -1.000000, -0.000001987560, 0.000000, -1.000000, 0.000002528770, 0.000000, -1.000000, 1.789670e-7, 0.000000, -1.000000, 9.209510e-7, 0.000000, -1.000000, 0.000000, 0.000000, -1.000000, -5.300220e-7, 0.000000, -1.000000, -0.00001590050, 0.000000, -1.000000, 0.000000, 0.000000, -1.000000, 0.000000, 0.000000, -1.000000, -0.000005109180, 0.000000, -1.000000, 0.000001276180, 0.000000, -1.000000, -0.00001590050, 0.000000, -1.000000, -0.000005994230, 0.000000, -1.000000, 0.000007950290, 0.000000, -1.000000, -0.000005962630, 0.000000, -1.000000, 0.000001045590, 0.000000, -1.000000, 0.000000, 0.000000, -1.000000, -5.456410e-7, 0.000000, -1.000000, 0.000000, 0.000000, -1.000000, -0.000007108980, 0.000000, -1.000000, 0.00001590040, 0.000000, -1.000000, 0.00001590050, 0.000000, -1.000000, 5.300170e-7, 0.000000, -1.000000, 0.000005109180, 0.000000, -1.000000, 4.293030e-7, 0.000000, -1.000000, 0.00001590040, 0.000000, -1.000000, 0.000004349500, 0.000000, -1.000000, 0.000000, 0.000000, -1.000000, 1.218960e-7, 0.000000, 1.000000, 0.000000, 0.000000, 1.000000, -0.000001599970, 0.000000, 1.000000, -0.00001962330, 0.000000, 1.000000, -0.000006802190, 0.000000, 1.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 1.000000, 0.00003924690, 0.000000, 1.000000, 0.00005254920, 0.000000, 1.000000, -0.00002168780, 0.000000, 1.000000, -0.000003624310, 0.000000, 1.000000, 0.00001261080, 0.000000, 1.000000, -3.270540e-7, 0.000000, 1.000000, -0.000009811670, 0.000000, 1.000000, 0.000000, 0.000000, 1.000000, -6.348200e-7, 0.000000, 1.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 1.000000, -0.00003924630, 0.000000, 1.000000, 0.000008119310, 0.000000, 1.000000, 0.000000, 0.000000, 1.000000, -0.00003924650, 0.000000, 1.000000, -0.000001308220, 0.000000, 1.000000, 0.00001261080, 0.000000, 1.000000, 0.000002659380, 0.000000, 1.000000, 0.00003924700, 0.000000, 1.000000, 5.403860e-7, 0.000000, 1.000000, 0.000000, 0.000000, 1.000000], 3);
      let indices = [0, 1, 2, 1, 3, 4, 3, 5, 6, 5, 7, 8, 7, 9, 10, 9, 11, 12, 11, 13, 14, 13, 15, 16, 15, 17, 18, 17, 19, 20, 19, 21, 22, 21, 23, 24, 23, 25, 26, 25, 27, 28, 27, 29, 30, 29, 31, 32, 31, 33, 34, 33, 35, 36, 35, 37, 38, 37, 39, 40, 39, 41, 42, 41, 43, 44, 43, 45, 46, 45, 47, 48, 48, 47, 49, 50, 49, 51, 52, 51, 53, 53, 54, 55, 54, 56, 57, 56, 58, 59, 60, 61, 62, 63, 0, 64, 58, 63, 65, 66, 67, 68, 59, 65, 69, 65, 64, 70, 57, 59, 71, 55, 57, 72, 73, 55, 74, 52, 73, 75, 50, 52, 76, 48, 50, 77, 46, 48, 78, 44, 46, 79, 42, 44, 80, 40, 42, 81, 38, 40, 82, 36, 38, 83, 34, 36, 84, 32, 34, 85, 30, 32, 86, 28, 30, 87, 26, 28, 88, 24, 26, 89, 22, 24, 90, 20, 22, 91, 18, 20, 92, 16, 18, 93, 14, 16, 94, 12, 14, 95, 10, 12, 96, 8, 10, 97, 6, 8, 98, 4, 6, 99, 2, 4, 100, 64, 2, 101, 64, 0, 2, 2, 1, 4, 4, 3, 6, 6, 5, 8, 8, 7, 10, 10, 9, 12, 12, 11, 14, 14, 13, 16, 16, 15, 18, 18, 17, 20, 20, 19, 22, 22, 21, 24, 24, 23, 26, 26, 25, 28, 28, 27, 30, 30, 29, 32, 32, 31, 34, 34, 33, 36, 36, 35, 38, 38, 37, 40, 40, 39, 42, 42, 41, 44, 44, 43, 46, 46, 45, 48, 50, 48, 49, 52, 50, 51, 73, 52, 53, 73, 53, 55, 55, 54, 57, 57, 56, 59, 102, 103, 104, 104, 105, 102, 106, 107, 108, 108, 109, 62, 62, 110, 111, 111, 112, 62, 113, 114, 115, 115, 116, 60, 60, 117, 118, 118, 119, 120, 120, 121, 122, 122, 123, 61, 61, 124, 125, 125, 126, 61, 127, 128, 129, 129, 130, 102, 102, 105, 106, 106, 108, 62, 62, 112, 113, 113, 115, 60, 60, 118, 61, 120, 122, 61, 61, 126, 127, 127, 129, 102, 102, 106, 62, 62, 113, 60, 118, 120, 61, 61, 127, 102, 102, 62, 61, 65, 63, 64, 59, 58, 65, 131, 132, 133, 133, 134, 135, 135, 136, 137, 137, 138, 68, 68, 139, 140, 140, 141, 68, 142, 143, 66, 144, 145, 66, 66, 146, 147, 148, 149, 147, 147, 150, 151, 151, 152, 67, 67, 153, 154, 154, 155, 67, 156, 157, 158, 158, 159, 131, 131, 133, 68, 135, 137, 68, 68, 141, 142, 143, 144, 66, 146, 148, 147, 147, 151, 67, 67, 155, 156, 156, 158, 67, 133, 135, 68, 68, 142, 66, 66, 147, 67, 67, 158, 131, 131, 68, 67, 71, 59, 69, 69, 65, 70, 72, 57, 71, 74, 55, 72, 75, 73, 74, 76, 52, 75, 77, 50, 76, 78, 48, 77, 79, 46, 78, 80, 44, 79, 81, 42, 80, 82, 40, 81, 83, 38, 82, 84, 36, 83, 85, 34, 84, 86, 32, 85, 87, 30, 86, 88, 28, 87, 89, 26, 88, 90, 24, 89, 91, 22, 90, 92, 20, 91, 93, 18, 92, 94, 16, 93, 95, 14, 94, 96, 12, 95, 97, 10, 96, 98, 8, 97, 99, 6, 98, 100, 4, 99, 101, 2, 100, 70, 64, 101];
      this._geometry.setAttribute('normal', this._normals);
      this._geometry.setAttribute('position', this._points);
      this._geometry.setAttribute('skinIndex', skinIndices);
      this._geometry.setAttribute('skinWeight', skinWeights);
      this._geometry.setIndex(indices);


      this._mesh = new THREE.SkinnedMesh(this._geometry, material );
      
      let bone = new THREE.Bone();

      bone.name = "Bone";
      bone.position.set(0, -1.3597299641787686e-7, -4.1803297996521);
      bone.parent = window.usdRoot;
      window.usdRoot.add(bone)
      let bone001 = new THREE.Bone();

      bone001.name = "Bone001";

      bone001.position.set(-2.845390803948676e-13, 0.027977522455514672, 4.187077045440674);
      bone001.rotation.set(
        -0.4019099357092103, // Rotation around x-axis in radians
        -0.0005798450768539914, // Rotation around y-axis in radians
        9.5590337806382e-11  // Rotation around z-axis in radians
      );
      bone001.quaternion.setFromEuler(bone001.rotation);
      bone001.scale.set(1, 0.9999999881244582, 0.9999998689151687);
      bone001.parent = bone;
      bone.children = [bone001];
      const frames = [0.04166661947965622, 0.08333330601453781, 0.125, 0.16666659712791443, 0.20833329856395721, 0.25, 0.29166659712791443, 0.3333333134651184, 0.3750000298023224, 0.41666659712791443, 0.4583333134651184, 0.5, 0.5416666865348816, 0.5833333134651184, 0.625, 0.6666666865348816, 0.7083333134651184, 0.75, 0.7916666865348816, 0.8333333134651184, 0.8750000596046448, 0.9166666865348816, 0.9583333134651184, 1, 1.0416669845581055, 1.0833330154418945, 1.125, 1.1666669845581055, 1.2083330154418945, 1.25, 1.2916669845581055, 1.3333330154418945, 1.3750001192092896, 1.4166669845581055, 1.4583330154418945, 1.5, 1.5416669845581055, 1.5833330154418945, 1.6250001192092896, 1.6666669845581055, 1.7083330154418945, 1.75, 1.7916669845581055, 1.8333330154418945, 1.8750001192092896, 1.9166669845581055, 1.9583330154418945, 2, 2.0416669845581055, 2.0833330154418945];
      const position = new THREE.VectorKeyframeTrack('Bone001.position', 
      frames,
      [-3.4530497493474865e-14, 0.027977488934993744, 4.187077045440674, -4.5771498841541e-14, 0.027977488934993744, 4.187077045440674, -5.704029642280423e-14, 0.02797750011086464, 4.187077045440674, -6.830910078033103e-14, 0.02797750011086464, 4.187077045440674, -7.955009535213359e-14, 0.02797750011086464, 4.187077045440674, -9.084659429890382e-14, 0.02797750011086464, 4.187077045440674, -1.0208800222278464e-13, 0.02797750011086464, 4.187077045440674, -1.1335600698120923e-13, 0.02797750011086464, 4.187077045440674, -1.245970015530118e-13, 0.02797750011086464, 4.187077045440674, -1.3586600919844594e-13, 0.027977509424090385, 4.187077045440674, -1.471070037702485e-13, 0.027977509424090385, 4.187077045440674, -1.5840401093678708e-13, 0.027977509424090385, 4.187077045440674, -1.6964500550858963e-13, 0.027977509424090385, 4.187077045440674, -1.8091301026701423e-13, 0.027977509424090385, 4.187077045440674, -1.9218200435992122e-13, 0.027977509424090385, 4.187077045440674, -2.0345101200535537e-13, 0.02797752059996128, 4.187077045440674, -2.147470162848844e-13, 0.02797752059996128, 4.187077045440674, -2.2596101422259207e-13, 0.02797752059996128, 4.187077045440674, -2.372299947629719e-13, 0.02797752059996128, 4.187077045440674, -2.484979995213965e-13, 0.02797752059996128, 4.187077045440674, -2.5976700716683065e-13, 0.02797752059996128, 4.187077045440674, -2.7100801529116036e-13, 0.02797752059996128, 4.187077045440674, -2.8230502245769895e-13, 0.02797752059996128, 4.187077045440674, -2.935180039558699e-13, 0.027977529913187027, 4.187077045440674, -3.0478701160130406e-13, 0.027977529913187027, 4.187077045440674, -2.9398998426660716e-13, 0.027977529913187027, 4.187077045440674, -2.8316501162091445e-13, 0.02797752059996128, 4.187077045440674, -2.7236801139127187e-13, 0.02797752059996128, 4.187077045440674, -2.6154301164052485e-13, 0.02797752059996128, 4.187077045440674, -2.5071901477678737e-13, 0.02797752059996128, 4.187077045440674, -2.399499869631949e-13, 0.02797752059996128, 4.187077045440674, -2.2909701479639777e-13, 0.02797752059996128, 4.187077045440674, -2.1830000101422803e-13, 0.02797752059996128, 4.187077045440674, -2.075030143371126e-13, 0.02797752059996128, 4.187077045440674, -1.9670601410747002e-13, 0.027977509424090385, 4.187077045440674, -1.858820036912054e-13, 0.027977509424090385, 4.187077045440674, -1.7505700394045837e-13, 0.027977509424090385, 4.187077045440674, -1.6426000371081578e-13, 0.027977509424090385, 4.187077045440674, -1.534630034811732e-13, 0.027977509424090385, 4.187077045440674, -1.426110070963313e-13, 0.027977509424090385, 4.187077045440674, -1.318140068666887e-13, 0.027977509424090385, 4.187077045440674, -1.2101700663704612e-13, 0.02797750011086464, 4.187077045440674, -1.1021999963113996e-13, 0.02797750011086464, 4.187077045440674, -9.936759667048337e-14, 0.02797750011086464, 4.187077045440674, -8.857059644084078e-14, 0.02797750011086464, 4.187077045440674, -7.777369785515187e-14, 0.02797750011086464, 4.187077045440674, -6.694909790395595e-14, 0.02797750011086464, 4.187077045440674, -5.615209767431337e-14, 0.02797750011086464, 4.187077045440674, -4.532749772311745e-14, 0.027977488934993744, 4.187077045440674, -3.4530497493474865e-14, 0.027977488934993744, 4.187077045440674]);
      
      const quaternion = new THREE.QuaternionKeyframeTrack('Bone001.quaternion', frames,
      [-4.6566102085421335e-9, 0.0002899225219152868, 4.162090377207717e-12, -0.9999999403953552, 0.012327802367508411, 0.00028990054852329195, -0.0000035741229567065602, -0.9999240040779114, 0.024695931002497673, 0.0002898341335821897, -0.0000071599129114474636, -0.9996950030326843, 0.03709890693426132, 0.00028972295694984496, -0.000010755836228781845, -0.9993115663528442, 0.04953110218048096, 0.00028956664027646184, -0.000014360211025632452, -0.9987725615501404, 0.061986807733774185, 0.0002893649507313967, -0.000017971420675166883, -0.9980769157409668, 0.07446031272411346, 0.00028911783010698855, -0.000021587768060271628, -0.997223973274231, 0.08694570511579514, 0.00028882475453428924, -0.000025207476937794127, -0.9962130188941956, 0.0994371846318245, 0.0002884858113247901, -0.00002882915396185126, -0.9950438141822815, 0.11192873120307922, 0.00028810082585550845, -0.0000324506800097879, -0.9937162399291992, 0.12441445887088776, 0.0002876700891647488, -0.00003607052713050507, -0.9922302961349487, 0.13688841462135315, 0.0002871935139410198, -0.00003968711826018989, -0.9905864596366882, 0.14934468269348145, 0.00028667121659964323, -0.00004329836156102829, -0.9887851476669312, 0.16177722811698914, 0.0002861035172827542, -0.00004690287460107356, -0.9868272542953491, 0.17418023943901062, 0.0002854908525478095, -0.000050498972996138036, -0.9847137331962585, 0.18654786050319672, 0.0002848332514986396, -0.00005408444121712819, -0.9824458360671997, 0.1988743245601654, 0.00028413126710802317, -0.000057658256991999224, -0.9800249338150024, 0.21115389466285706, 0.00028338556876406074, -0.0000612183430348523, -0.9774527549743652, 0.22338096797466278, 0.0002825966803357005, -0.00006476328417193145, -0.9747311472892761, 0.23554988205432892, 0.0002817647182382643, -0.00006829135963926092, -0.9718621969223022, 0.24765545129776, 0.0002808909921441227, -0.0000718010269338265, -0.9688481092453003, 0.2596922516822815, 0.00027997582219541073, -0.00007529092545155436, -0.9656913876533508, 0.2716551721096039, 0.00027901987778022885, -0.00007875907613197342, -0.9623945951461792, 0.2835392355918884, 0.00027802420663647354, -0.00008220469317166135, -0.9589605927467346, 0.2953396439552307, 0.0002769898856058717, -0.00008562587754568085, -0.9553922414779663, 0.2840130627155304, 0.0002779837523121387, -0.00008234185952460393, -0.9588203430175781, 0.27260908484458923, 0.0002789416757877916, -0.00007903578807599843, -0.9621248245239258, 0.26113200187683105, 0.0002798631612677127, -0.00007570812158519402, -0.9653030633926392, 0.24958626925945282, 0.00028074721922166646, -0.00007236083911266178, -0.9683524966239929, 0.23797638714313507, 0.000281593413092196, -0.00006899495929246768, -0.9712708592414856, 0.22630704939365387, 0.0002824008697643876, -0.00006561177724506706, -0.9740559458732605, 0.21458309888839722, 0.00028316894895397127, -0.00006221249350346625, -0.9767056703567505, 0.20280921459197998, 0.00028389738872647285, -0.000058798988902708516, -0.9792181849479675, 0.19099058210849762, 0.00028458572342060506, -0.00005537259130505845, -0.9815918207168579, 0.17913199961185455, 0.0002852331381291151, -0.00005193457764107734, -0.9838249683380127, 0.16723862290382385, 0.0002858394000213593, -0.00004848641037824564, -0.9859163761138916, 0.15531565248966217, 0.0002864043053705245, -0.00004502971933106892, -0.9878648519515991, 0.14336833357810974, 0.0002869276504497975, -0.00004156567592872307, -0.9896693825721741, 0.13140177726745605, 0.0002874088240787387, -0.00003809635745710693, -0.9913291335105896, 0.11942128092050552, 0.0002878479426726699, -0.00003462304448476061, -0.9928436279296875, 0.10743213444948196, 0.00028824477340094745, -0.000031147039408097044, -0.9942123889923096, 0.095439612865448, 0.0002885991707444191, -0.000027670073905028403, -0.9954351782798767, 0.08344891667366028, 0.00028891145484521985, -0.000024193777790060267, -0.9965120553970337, 0.07146533578634262, 0.0002891811600420624, -0.000020719442545669153, -0.9974430799484253, 0.059494033455848694, 0.00028940913034603, -0.000017248685253434815, -0.9982286691665649, 0.04754016920924187, 0.00028959469636902213, -0.000013782995665678754, -0.9988692998886108, 0.03560884669423103, 0.00028973876032978296, -0.000010323827154934406, -0.9993657469749451, 0.023705055937170982, 0.00028984120581299067, -0.000006872635367471958, -0.999718964099884, 0.011833779513835907, 0.0002899023238569498, -0.0000034308952763240086, -0.9999299645423889, -4.6566102085421335e-9, 0.0002899225219152868, 4.162090377207717e-12, -0.9999999403953552]);
      const scale = new THREE.VectorKeyframeTrack('Bone001.scale', frames, 
      [1.0000001192092896, 0.9999999403953552, 1, 1.0000001192092896, 0.9999999403953552, 1, 1.0000001192092896, 0.9999999403953552, 1, 1.0000001192092896, 1, 1, 1.0000001192092896, 0.9999999403953552, 1, 1.0000001192092896, 0.9999999403953552, 1, 1.0000001192092896, 1, 1, 1.0000001192092896, 0.9999998807907104, 0.9999999403953552, 1.0000001192092896, 0.9999999403953552, 0.9999999403953552, 1.0000001192092896, 1, 1, 1.0000001192092896, 0.9999998807907104, 0.9999999403953552, 1.0000001192092896, 0.9999998211860657, 0.9999999403953552, 1.0000001192092896, 0.9999999403953552, 1, 1, 1, 0.9999998807907104, 1, 1, 0.9999998807907104, 1, 1, 0.9999999403953552, 1, 1, 0.9999998807907104, 1, 1, 0.9999999403953552, 1, 1, 0.9999998807907104, 0.9999999403953552, 1, 0.9999998211860657, 0.9999999403953552, 1, 0.9999998807907104, 0.9999999403953552, 0.9999999403953552, 0.9999999403953552, 1, 1, 0.9999998807907104, 1, 0.9999999403953552, 0.9999998211860657, 1, 0.9999999403953552, 0.9999998807907104, 1, 1, 0.9999998807907104, 1, 0.9999999403953552, 0.9999998807907104, 0.9999999403953552, 1.0000001192092896, 0.9999999403953552, 0.9999999403953552, 1, 1, 0.9999999403953552, 1, 0.9999998211860657, 1, 0.9999999403953552, 0.9999998807907104, 1, 0.9999998807907104, 0.9999998807907104, 1, 1, 0.9999998211860657, 1, 1, 0.9999998807907104, 1, 1, 0.9999998807907104, 1, 1, 0.9999998807907104, 1, 1, 0.9999999403953552, 1.0000001192092896, 0.9999999403953552, 1, 1.0000001192092896, 0.9999999403953552, 1, 1.0000001192092896, 0.9999998211860657, 0.9999999403953552, 1.0000001192092896, 0.9999999403953552, 1, 1.0000001192092896, 0.9999999403953552, 1, 1.0000001192092896, 0.9999999403953552, 1, 1.0000001192092896, 1, 1, 1.0000001192092896, 1, 1, 1.0000001192092896, 0.9999999403953552, 1, 1.0000001192092896, 0.9999998211860657, 0.9999999403953552, 1.0000001192092896, 0.9999999403953552, 1, 1.0000001192092896, 0.9999999403953552, 0.9999999403953552, 1.0000001192092896, 0.9999999403953552, 1]);
      // Create an animation clip
      const clip = new THREE.AnimationClip('animation0', 2.0833330154418945, [position, quaternion, scale]);
      
      const inverseOne = new THREE.Matrix4(); 
      inverseOne.set( 0, 1, 0, 0, 
        -1, 0, 0, 0,
        0, 0, 1, 0,
        0, 1.3597299641787686e-7, 4.1803297996521, 1 );

        const inverseTwo = new THREE.Matrix4(); 
      inverseTwo.set( 0, 1, 0, 0, 
        -0.9999998211860657, 0, 0.0005798449856229126, 0,
        0.0005798449856229126, 0, 0.9999998211860657, 0,
        -0.000003912100055458723, -0.02797728031873703, -0.006746708881109953, 1 );


      let skeleton = new THREE.Skeleton([bone, bone001], [inverseOne, inverseTwo]);

      
      this._mesh.bind(skeleton);
      const action = window.mixer.clipAction( clip );
      action.play();
    }
    else {
      return;
      this._mesh = new THREE.Mesh( this._geometry, material );
    }

    
    this._mesh.castShadow = true;
    this._mesh.receiveShadow = true;

    // ID can contain paths, we strip those here
    let _name = id;
    let lastSlash = _name.lastIndexOf('/');
    if (lastSlash >= 0) {
      _name = _name.substring(lastSlash + 1);
    }
    this._mesh.name = _name;

    // console.log("Creating HydraMesh: " + id + " -> " + _name);

    console.log("skinnedMesh: ", this._mesh);
    
    window.usdRoot.add(this._mesh); // FIXME
  }

  updateOrder(attribute, attributeName, dimension = 3) {
    if (this._isSkinned ) return;
    if (debugMeshes) console.log("updateOrder", attribute, attributeName, dimension);
    if (attribute && this._indices) {
      let values = [];
      for (let i = 0; i < this._indices.length; i++) {
        let index = this._indices[i]
        for (let j = 0; j < dimension; ++j) {
          values.push(attribute[dimension * index + j]);
        }
      }
      this._geometry.setAttribute( attributeName, new THREE.Float32BufferAttribute( values, dimension ) );
    }
  }

  updateIndices(indices) {
    if (debugMeshes) console.log("updateIndices", indices);
    if (this._isSkinned ) return;
    this._indices = [];
    for (let i = 0; i< indices.length; i++) {
      this._indices.push(indices[i]);
    }
    //this._geometry.setIndex( indicesArray );
    this.updateOrder(this._points, 'position');
    this.updateOrder(this._normals, 'normal');
    if (this._colors) {
      this.updateOrder(this._colors, 'color');
    }
    if (this._uvs) {
      this.updateOrder(this._uvs, 'uv', 2);
      this._geometry.attributes.uv2 = this._geometry.attributes.uv;
    }
  }

  setTransform(matrix) {
    this._mesh.matrix.set(...matrix);
    this._mesh.matrix.transpose();
    this._mesh.matrixAutoUpdate = false;
  }

  /**
   * Sets automatically generated normals on the mesh. Should only be used if there are no authored normals.
   * @param {} normals 
   */
  updateNormals(normals) {
    if (this._isSkinned ) return;
    // don't apply automatically generated normals if there are already authored normals.
    if (this._geometry.hasAttribute('normal')) return;

    this._normals = normals.slice(0);
    this.updateOrder(this._normals, 'normal');
  }

  setNormals(data, interpolation) {
    if (this._isSkinned ) return;
    if (interpolation === 'facevarying') {
      // The UV buffer has already been prepared on the C++ side, so we just set it
      this._geometry.setAttribute('normal', new THREE.Float32BufferAttribute(data, 3));
    } else if (interpolation === 'vertex') {
      // We have per-vertex UVs, so we need to sort them accordingly
      this._normals = data.slice(0);
      this.updateOrder(this._normals, 'normal');
    }
  }

  // This is always called before prims are updated
  setMaterial(materialId) {
    console.log('Material: ' + materialId);
    if (this._interface.materials[materialId]) {

      this._mesh.material = this._interface.materials[materialId]._material;
    }
    console.log("this! ", this)
  }

  setGeomSubsetMaterial(sections) {
    //console.log("setting subset material: ", this._id, sections)

    for(let i = 0; i < sections.length; i++){
      const section = sections[i];
      if (this._interface.materials[section.materialId]) {
        this._materials.push(this._interface.materials[section.materialId]._material);
        this._geometry.addGroup(section.start, section.length, i + 1);
      }
    }

    this._mesh = new THREE.Mesh( this._geometry, this._materials);
    window.usdRoot.add(this._mesh);
  }

  setDisplayColor(data, interpolation) {
    if (disableMaterials) return;

    let wasDefaultMaterial = false;
    if (this._mesh.material === defaultMaterial) {
      this._mesh.material = this._mesh.material.clone();
      wasDefaultMaterial = true;
    }

    this._colors = null;

    if (interpolation === 'constant') {
      this._mesh.material.color = new THREE.Color().fromArray(data);
    } else if (interpolation === 'vertex') {
      // Per-vertex buffer attribute
      this._mesh.material.vertexColors = true;
      if (wasDefaultMaterial) {
        // Reset the pink debugging color
        this._mesh.material.color = new THREE.Color(0xffffff);
      }
      this._colors = data.slice(0);
      this.updateOrder(this._colors, 'color');
    } else {
      if (warningMessagesToCount.has(interpolation)) {
        warningMessagesToCount.set(interpolation, warningMessagesToCount.get(interpolation) + 1);
      }
      else {
        warningMessagesToCount.set(interpolation, 1);
        console.warn(`Unsupported displayColor interpolation type '${interpolation}'.`);
      }
    }
  }

  setUV(data, dimension, interpolation) {
    // TODO: Support multiple UVs. For now, we simply set uv = uv2, which is required when a material has an aoMap.
    this._uvs = null;

    if (interpolation === 'facevarying') {
      // The UV buffer has already been prepared on the C++ side, so we just set it
      this._geometry.setAttribute('uv', new THREE.Float32BufferAttribute(data, dimension));
    } else if (interpolation === 'vertex') {
      // We have per-vertex UVs, so we need to sort them accordingly
      this._uvs = data.slice(0);
      this.updateOrder(this._uvs, 'uv', 2);
    }

    if (this._geometry.hasAttribute('uv'))
      this._geometry.attributes.uv2 = this._geometry.attributes.uv;
  }

  updatePrimvar(name, data, dimension, interpolation) {
    if (!name) return;

    if (name === 'points') { // || name === 'normals') {
      // Points and normals are set separately
      return;
    }

    // console.log('Setting PrimVar: ' + name + ", interpolation: " + interpolation);

    // TODO: Support multiple UVs. For now, we simply set uv = uv2, which is required when a material has an aoMap.
    if (name.startsWith('st')) {
      name = 'uv';
    }

    switch(name) {
      case 'displayColor':
        this.setDisplayColor(data, interpolation);
        break;
      case 'uv':
      case "UVMap":
      case "uvmap":
      case "uv0":
      case "UVW":
      case "uvw":
        this.setUV(data, dimension, interpolation);
        break;
      case "normals":
        this.setNormals(data, interpolation); 
        break;
      default:
        if (warningMessagesToCount.has(name)) {
          warningMessagesToCount.set(name, warningMessagesToCount.get(name) + 1);
        }
        else {
          warningMessagesToCount.set(name, 1);
          console.warn('Unsupported primvar: ', name);
        }
    }
  }

  skelDetected(id, primVarName) {
    console.warn('UsdSkel detected. Skinned Meshes are not fully supported: ', primVarName, id);
    console.log("this.meshes: ", this)
  }

  updatePoints(points) {
    if (this._isSkinned ) return;
    this._points = points.slice(0);
    this.updateOrder(this._points, 'position');
  }

  commit() {
    // Nothing to do here. All Three.js resources are already updated during the sync phase.
  }

}

let warningMessagesToCount = new Map();
let defaultMaterial;

class HydraMaterial {
  // Maps USD preview material texture names to Three.js MeshPhysicalMaterial names
  static usdPreviewToMeshPhysicalTextureMap = {
    'diffuseColor': 'map',
    'clearcoat': 'clearcoatMap',
    'clearcoatRoughness': 'clearcoatRoughnessMap',
    'emissiveColor': 'emissiveMap',
    'occlusion': 'aoMap',
    'roughness': 'roughnessMap',
    'metallic': 'metalnessMap',
    'normal': 'normalMap',
    'opacity': 'alphaMap'
  };

  static usdPreviewToColorSpaceMap = {
    'diffuseColor': THREE.SRGBColorSpace,
    'emissiveColor': THREE.SRGBColorSpace,
    'opacity': THREE.SRGBColorSpace,
  };

  static channelMap = {
    // Three.js expects many 8bit values such as roughness or metallness in a specific RGB texture channel.
    // We could write code to combine multiple 8bit texture files into different channels of one RGB texture where it
    // makes sense, but that would complicate this loader a lot. Most Three.js loaders don't seem to do it either.
    // Instead, we simply provide the 8bit image as an RGBA texture, even though this might be less efficient.
    'r': THREE.RGBAFormat,
    'g': THREE.RGBAFormat,
    'b': THREE.RGBAFormat,
    'rgb': THREE.RGBAFormat,
    'rgba': THREE.RGBAFormat
  };

  // Maps USD preview material property names to Three.js MeshPhysicalMaterial names
  static usdPreviewToMeshPhysicalMap = {
    'clearcoat': 'clearcoat',
    'clearcoatRoughness': 'clearcoatRoughness',
    'diffuseColor': 'color',
    'emissiveColor': 'emissive',
    'ior': 'ior',
    'metallic': 'metalness',
    'opacity': 'opacity',
    'roughness': 'roughness',
    'opacityThreshold': 'alphaTest',
  };

  constructor(id, hydraInterface) {
    this._id = id;
    this._nodes = {};
    this._interface = hydraInterface;
    if (!defaultMaterial) {
      defaultMaterial = new THREE.MeshPhysicalMaterial({
        side: THREE.DoubleSide,
        color: new THREE.Color(0xff2997), // a bright pink color to indicate a missing material
        envMap: window.envMap,
      });
    }
    // proper color when materials are disabled
    if (disableMaterials)
      defaultMaterial.color = new THREE.Color(0x999999);

    this._material = defaultMaterial;

    if (debugMaterials) console.log("Hydra Material", this)
  }

  updateNode(networkId, path, parameters) {
    if (debugTextures) console.log('Updating Material Node: ' + networkId + ' ' + path, parameters);
    this._nodes[path] = parameters;
  }

  convertWrap(usdWrapMode) {
     if (usdWrapMode === undefined)
        return THREE.RepeatWrapping;
    
    const WRAPPINGS = {
			'repeat': 1000, // RepeatWrapping
			'clamp': 1001, // ClampToEdgeWrapping
			'mirror': 1002 // MirroredRepeatWrapping
		};
    
    if (WRAPPINGS[usdWrapMode])
      return WRAPPINGS[usdWrapMode];
    
    return THREE.RepeatWrapping;
  }
  
  assignTexture(mainMaterial, parameterName) {
    return new Promise((resolve, reject) => {
      const materialParameterMapName = HydraMaterial.usdPreviewToMeshPhysicalTextureMap[parameterName];
      if (materialParameterMapName === undefined) {
        console.warn(`Unsupported material texture parameter '${parameterName}'.`);
        resolve();
        return;
      }
      if (mainMaterial[parameterName] && mainMaterial[parameterName].nodeIn) {
        const nodeIn = mainMaterial[parameterName].nodeIn;
        if (!nodeIn.resolvedPath) {
          console.warn("Texture node has no file!", nodeIn);
        }
        if (debugTextures)
          console.log("Assigning texture with resolved path", parameterName, nodeIn.resolvedPath);
        const textureFileName = nodeIn.resolvedPath?.replace("./", "");
        const channel = mainMaterial[parameterName].inputName;

        // For debugging
        const matName = Object.keys(this._nodes).find(key => this._nodes[key] === mainMaterial);
        if (debugTextures) console.log(`Setting texture '${materialParameterMapName}' (${textureFileName}) of material '${matName}'... with channel '${channel}'`);

        this._interface.registry.getTexture(textureFileName).then(texture => {
          if (!this._material) {
            console.error("Material not set when trying to assign texture, this is likely a bug");
            resolve();
          }
          // console.log("getTexture", texture, nodeIn);
          if (materialParameterMapName === 'alphaMap') {
            // If this is an opacity map, check if it's using the alpha channel of the diffuse map.
            // If so, simply change the format of that diffuse map to RGBA and make the material transparent.
            // If not, we need to copy the alpha channel into a new texture's green channel, because that's what Three.js
            // expects for alpha maps (not supported at the moment).
            // NOTE that this only works if diffuse maps are always set before opacity maps, so the order of
            // 'assingTexture' calls for a material matters.
            if (nodeIn.file === mainMaterial.diffuseColor?.nodeIn?.file && channel === 'a') {
              this._material.map.format = THREE.RGBAFormat;
            } else {
              // TODO: Extract the alpha channel into a new RGB texture.
              console.warn("Separate alpha channel is currently not supported.", nodeIn.file, mainMaterial.diffuseColor?.nodeIn?.file, channel);
            }
            if (!this._material.alphaClip)
              this._material.transparent = true;
            
            this._material.needsUpdate = true;
            resolve();
            return;
          } else if (materialParameterMapName === 'metalnessMap') {
            this._material.metalness = 1.0;
          } else if (materialParameterMapName === 'roughnessMap') {
            this._material.roughness = 1.0;
          } else if (materialParameterMapName === 'emissiveMap') {
            this._material.emissive = new THREE.Color(0xffffff);
          } else if (!HydraMaterial.channelMap[channel]) {
            console.warn(`Unsupported texture channel '${channel}'!`);
            resolve();
            return;
          }
          // TODO need to apply bias/scale to the texture in some cases.
          // May be able to extract that for metalness/roughness/opacity/normalScale

          // Clone texture and set the correct format.
          const clonedTexture = texture.clone();
          let targetSwizzle = 'rgba';

          if (materialParameterMapName == 'roughnessMap' && channel != 'g') {
            targetSwizzle = '0' + channel + '11';
          }
          if (materialParameterMapName == 'metalnessMap' && channel != 'b') {
            targetSwizzle = '01' + channel + '1';
          }
          if (materialParameterMapName == 'occlusionMap' && channel != 'r') {
            targetSwizzle = channel + '111';
          }
          if (materialParameterMapName == 'opacityMap' && channel != 'a') {
            targetSwizzle = channel + channel + channel + channel;
          }

          clonedTexture.colorSpace = HydraMaterial.usdPreviewToColorSpaceMap[parameterName] || THREE.LinearSRGBColorSpace;
          
          // console.log("Cloned texture", clonedTexture, "swizzled with", targetSwizzle);
          // clonedTexture.image = HydraMaterial._swizzleImageChannels(clonedTexture.image, targetSwizzle);
          // if (materialParameterToTargetChannel[materialParameterMapName] && channel != materialParameterToTargetChannel[materialParameterMapName])
          if (targetSwizzle != 'rgba')
          {
            clonedTexture.image = HydraMaterial._swizzleImageChannels(clonedTexture.image, targetSwizzle);
          }
          // clonedTexture.image = HydraMaterial._swizzleImageChannels(clonedTexture.image, channel, 'g')

          clonedTexture.format = HydraMaterial.channelMap[channel];
          clonedTexture.needsUpdate = true;
          if (nodeIn.st && nodeIn.st.nodeIn) {
            const uvData = nodeIn.st.nodeIn;
            // console.log("Tiling data", uvData);
            
            // TODO this is messed up but works for scale and translation, not really for rotation.
            // Refer to https://github.com/mrdoob/three.js/blob/e5426b0514a1347d7aafca69aa34117503c1be88/examples/jsm/exporters/USDZExporter.js#L461
            // (which is also not perfect but close)
            
            const rotation = uvData.rotation ? (uvData.rotation / 180 * Math.PI) : 0;
            const offset = uvData.translation ? new THREE.Vector2(uvData.translation[0], uvData.translation[1]) : new THREE.Vector2(0,0);
            const repeat = uvData.scale ? new THREE.Vector2(uvData.scale[0], uvData.scale[1]) : new THREE.Vector2(1,1);
            
            const xRotationOffset = Math.sin( rotation );
            const yRotationOffset = Math.cos( rotation );
            offset.y = offset.y - (1 - yRotationOffset) * repeat.y;
            offset.x = offset.x - xRotationOffset * repeat.x;
            // offset.y = 1 - offset.y - repeat.y;
            /*
            if (uvData.scale) 
              clonedTexture.repeat.set(uvData.scale[0], uvData.scale[1]);
            if (uvData.translation)
              clonedTexture.offset.set(uvData.translation[0], uvData.translation[1]);
            if (uvData.rotation)
            clonedTexture.rotation = uvData.rotation / 180 * Math.PI;   
            */
            
            clonedTexture.repeat.set(repeat.x, repeat.y);
            clonedTexture.offset.set(offset.x, offset.y);
            clonedTexture.rotation = rotation;
          }
          
          // TODO use nodeIn.wrapS and wrapT and map to THREE
          clonedTexture.wrapS = this.convertWrap(nodeIn.wrapS);
          clonedTexture.wrapT = this.convertWrap(nodeIn.wrapT);
          if (debugTextures) console.log("Setting texture " + materialParameterMapName + " to", clonedTexture)
          this._material[materialParameterMapName] = clonedTexture;
          this._material.needsUpdate = true;

          if (debugTextures) console.log("RESOLVED TEXTURE", matName, parameterName);
          resolve();
          return;
        }).catch(err => {
          console.warn("Error when loading texture", err);
          resolve();
          return;
        });
      } else {
        this._material[materialParameterMapName] = undefined;
        resolve();
        return;
      }
    });
  }

  // from https://github.com/mrdoob/three.js/blob/dev/src/math/ColorManagement.js
  static SRGBToLinear( c ) {
    return ( c < 0.04045 ) ? c * 0.0773993808 : Math.pow( c * 0.9478672986 + 0.0521327014, 2.4 );
  }
  
  static LinearToSRGB( c ) {
    return ( c < 0.0031308 ) ? c * 12.92 : 1.055 * ( Math.pow( c, 0.41666 ) ) - 0.055;
  }

  /**
   * Swizzle image channels (e.g. move red channel to green channel)
   * @param {*} image three.js image
   * @param {string} swizzle For example, "rgga". Must have max. 4 components. Can contain 0 and 1, e.g. "rgba1" is valid.
   * @returns three.js image
   */
  static _swizzleImageChannels( image, swizzle ) {
		if ( ( typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement ) ||
			( typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement ) ||
			( typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap ) ) {

			const canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );

			canvas.width = image.width;
			canvas.height = image.height;

			const context = canvas.getContext( '2d' );
			context.drawImage( image, 0, 0, image.width, image.height );

			const imageData = context.getImageData( 0, 0, image.width, image.height );
			const data = imageData.data;
      
      // console.log(data);
      
      const swizzleToIndex = {
        'r': 0,
        'g': 1,
        'b': 2,
        'a': 3,
        'x': 0,
        'y': 1,
        'z': 2,
        'w': 3,
        '0': 4, // set to 0
        '1': 5, // set to 1
        '-': -1, // passthrough
      };
      const arrayAccessBySwizzle = [4,4,4,4]; // empty value if nothing defined in the swizzle pattern
      for (let i = 0; i < swizzle.length; i++) {
        arrayAccessBySwizzle[i] = swizzleToIndex[swizzle[i]];
      }

      const dataEntry = data.slice(0);
			for ( let i = 0; i < data.length; i += 4 ) {
        dataEntry[0] = data[i];
        dataEntry[1] = data[i+1];
        dataEntry[2] = data[i+2];
        dataEntry[3] = data[i+3];
        dataEntry[4] = 0; // empty value
        dataEntry[5] = 1;

        const rAccess = arrayAccessBySwizzle[0];
        const gAccess = arrayAccessBySwizzle[1];
        const bAccess = arrayAccessBySwizzle[2];
        const aAccess = arrayAccessBySwizzle[3];

        if (rAccess !== -1)
				  data[ i ] = dataEntry[rAccess];
        if (gAccess !== -1)
          data[ i + 1 ] = dataEntry[gAccess];
        if (bAccess !== -1)
          data[ i + 2 ] = dataEntry[bAccess];
        if (aAccess !== -1)
          data[ i + 3 ] = dataEntry[aAccess];
			}

			context.putImageData( imageData, 0, 0 );
			return canvas;

		} else if ( image.data ) {
			const data = image.data.slice( 0 );

			for ( let i = 0; i < data.length; i ++ ) {
				if ( data instanceof Uint8Array || data instanceof Uint8ClampedArray ) {
					data[ i ] = Math.floor( this.SRGBToLinear( data[ i ] / 255 ) * 255 );
				} else {
					// assuming float
					data[ i ] = this.SRGBToLinear( data[ i ] );
				}
			}

			return {
				data: data,
				width: image.width,
				height: image.height
			};
		} else {
			console.warn( 'THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied.' );
			return image;
		}
	}

  assignProperty(mainMaterial, parameterName) {
    const materialParameterName = HydraMaterial.usdPreviewToMeshPhysicalMap[parameterName];
    if (materialParameterName === undefined) {
      console.warn(`Unsupported material parameter '${parameterName}'.`);
      return;
    }
    if (mainMaterial[parameterName] !== undefined && !mainMaterial[parameterName].nodeIn) {
      // console.log(`Assigning property ${parameterName}: ${mainMaterial[parameterName]}`);
      if (Array.isArray(mainMaterial[parameterName])) {
        this._material[materialParameterName] = new THREE.Color().fromArray(mainMaterial[parameterName]);
      } else {
        this._material[materialParameterName] = mainMaterial[parameterName];
        if (materialParameterName === 'opacity' && mainMaterial[parameterName] < 1.0) {
          this._material.transparent = true;
        }
        if (parameterName == 'opacityThreshold' && mainMaterial[parameterName] > 0.0) {
          this._material.transparent = false;
          this._material.alphaClip = true;
        }
      }
    }
  }

  async updateFinished(type, relationships) {
    for (let relationship of relationships) {
      relationship.nodeIn = this._nodes[relationship.inputId];
      relationship.nodeOut = this._nodes[relationship.outputId];
      relationship.nodeIn[relationship.inputName] = relationship;
      relationship.nodeOut[relationship.outputName] = relationship;
    }
    if (debugMaterials) console.log('Finalizing Material: ' + this._id);
    if (debugMaterials) console.log("updateFinished", type, relationships)

    // find the main material node
    let mainMaterialNode = undefined;
    for (let node of Object.values(this._nodes)) {
      if (node.diffuseColor) {
        mainMaterialNode = node;
        break;
      }
    }

    if (!mainMaterialNode || disableMaterials) {
      this._material = defaultMaterial;
      return;
    }

    // TODO: Ideally, we don't recreate the material on every update.
    // Creating a new one requires to also update any meshes that reference it. So we're relying on the C++ side to
    // call this before also calling `setMaterial` on the affected meshes.
    this._material = new THREE.MeshPhysicalMaterial({});
    this._material.side = THREE.DoubleSide;
    // split _id
    let _name = this._id;
    let lastSlash = _name.lastIndexOf('/');
    if (lastSlash >= 0)
      _name = _name.substring(lastSlash + 1);
    this._material.name = _name;

    // Assign textures
    const haveRoughnessMap = !!(mainMaterialNode.roughness && mainMaterialNode.roughness.nodeIn);
    const haveMetalnessMap = !!(mainMaterialNode.metallic && mainMaterialNode.metallic.nodeIn);
    const haveOcclusionMap = !!(mainMaterialNode.occlusion && mainMaterialNode.occlusion.nodeIn);

    if (debugMaterials) {
      console.log('Creating Material: ' + this._id, mainMaterialNode, {
        haveRoughnessMap,
        haveMetalnessMap,
        haveOcclusionMap
      });
    }

    if (!disableTextures) {
      const texturePromises = [];
      for (let key in HydraMaterial.usdPreviewToMeshPhysicalTextureMap) {
        texturePromises.push(this.assignTexture(mainMaterialNode, key));
      }
      await Promise.all(texturePromises);

      // Need to sanitize metallic/roughness/occlusion maps - if we want to export glTF they need to be identical right now
      if (haveRoughnessMap && !haveMetalnessMap)
      {
        if (debugMaterials) console.log(this._material.roughnessMap, this._material);
        this._material.metalnessMap = this._material.roughnessMap;
        if (this._material.metalnessMap) this._material.metalnessMap.needsUpdate = true;
        else console.error("Something went wrong with the texture promise; haveRoughnessMap is true but no roughnessMap was loaded.");
      }
      else if (haveMetalnessMap && !haveRoughnessMap)
      {
        this._material.roughnessMap = this._material.metalnessMap;
        if (this._material.roughnessMap) this._material.roughnessMap.needsUpdate = true;
        else console.error("Something went wrong with the texture promise; haveMetalnessMap is true but no metalnessMap was loaded.");
      }
      else if (haveMetalnessMap && haveRoughnessMap) {
        // need to merge textures
        // TODO
        console.warn("TODO separate metalness and roughness textures, need to be merged");
      }
    }

    // Assign material properties
    for (let key in HydraMaterial.usdPreviewToMeshPhysicalMap) {
      this.assignProperty(mainMaterialNode, key);
    }

    if (window.envMap) {
      this._material.envMap = window.envMap;
    }

    if (debugMaterials) console.log("Material Node \"" + this._material.name + "\"", mainMaterialNode, "Resulting Material", this._material);
  }
}

/*
class SdfPath {
  get name() { return this.GetName(); }
  get absoluteRootPath() { return this.AbsoluteRootPath(); }
  get reflexiveRelativePath() { return this.ReflexiveRelativePath(); }
}
*/

export class RenderDelegateInterface {

  constructor(filename, allPaths) {
    if (debugMaterials) console.log("RenderDelegateInterface", filename, allPaths);
    this.registry = new TextureRegistry(filename, allPaths);
    this.materials = {};
    this.meshes = {};
  }

  /**
   * Render Prims. See webRenderDelegate.h and webRenderDelegate.cpp
   * @param {string} typeId // translated from TfToken
   * @param {string} id // SdfPath.GetAsString()
   * @param {*} instancerId
   * @returns 
   */
  createRPrim(typeId, id, instancerId) {
    console.log('Creating RPrim: ', typeId, id, typeof id);

    
    let mesh;

    if (id === '/StageRoot/Scenes/Scene/DropListener_28/_56/Z_UP_57/Armature_58/Cylinder_61/Geometry'){
      console.log("whasssupp")
      mesh = new HydraMesh(id, this, true);
    }
    else{
      mesh = new HydraMesh(id, this);
    }
    this.meshes[id] = mesh;
    return mesh;
  }

  createBPrim(typeId, id) {
    if (debugPrims) console.log('Creating BPrim: ', typeId, id);
    /*let mesh = new HydraMesh(id, this);
    this.meshes[id] = mesh;
    return mesh;*/
  }

  createSPrim(typeId, id) {
    if (debugPrims) console.log('Creating SPrim: ', typeId, id);

    if (typeId === 'material') {
      let material = new HydraMaterial(id, this);
      this.materials[id] = material;
      return material;
    } else {
      return undefined;
    }
  }

  CommitResources() {
    for (const id in this.meshes) {
        const hydraMesh = this.meshes[id]
        hydraMesh.commit();
    }
  }
}
